#!/usr/bin/env python
#########################
## lk_k2db.py : 
##      A tool that creates or updates a database containing relevant WiFi
##	data from a kismet xml capture file
##
## Copyright (C) 2015 LAYAKK - www.layakk.com @layakk
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## PRERREQUISITES
## 	lk_screen_log.py (http://www.layakk.com/lab)
## USAGE
##	The input for this tool is a Kismet WiFi capture .netxml file.
##	Typically you can do this capture with:
##		kismet_server -qs -t PREFIX -c wlan0:hop=false,channel=1 &
##	but kismet is extremely versatile, so you should take a look at
##	kismet documentation to capture exactly what you want to.
##	After running kismet, you can incorporate the information of this 
##	kismet execution to your existing database, to create a new one or to
##	to take an additional action. There are two additional actions that
##	you can perform:
##		(1) Manually specify what ESSIDs are a target of your test, i.e., 
##		are network of your interest
##		(2) Clean malformed ESSIDs: when kismet uses a capture file
##		as a source, that has been generated by another tool (tcpdump, etc.),
##		it is possible that the capture has been taken without dropping 
##		erroneous frames and this can lead to malformed ESSIDs 
##		that are taken by kismet as legitimate ones, but they really 
##		represent an existing one. 
##		This option try to solve this situation by comparing "similar"
##		ESSIDs and asking the user if he thinks they are the same.
##		This is only here just in case you have to use a non-kismet 
##		capture as a source, because the right way to do it is not to 
##		allow such kind of frames. One way to do it is to use a virtual 
##		interface that has been created without the fcsfail flag set 
##		(see iw --help for more information).
#########################

###
### IMPORT SECTION
###
import time, datetime, os, re, sys
import xml.dom.minidom
import xml.etree.ElementTree as etree
from xml.dom.minidom import Node
from xml.sax.saxutils import escape
import sqlite3
import argparse
import os.path
import re
from lk_screen_log import lkScreenMsg, lkSMsgMoreIndent, lkSMsgLessIndent, lkSMsgSetIndentLevel, lkSMsgDontContinue

###
### FUNCTION SECTION
###
# create_argumentparser :       Creates the argument parser for this program
#	returns : the argument parser object
def create_argumentparser():
        desc =  'lk_k2db.py (v1.0) - Kismet XML to sqlite3 database extraction tool\n'
        desc += 'Copyright (c) 2015 Layakk (www.layakk.com) (@layakk)'

	parser=argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter, description=desc)

	parser.add_argument("-i", "--input", dest="filename", help="Path to netxml input file.")
	parser.add_argument("-o", "--output", dest="database", help="Path to Sqlite database file.", required=True)
	parser.add_argument("-w", "--overwrite", help="Include this option if you want the database to be averwritten instead of appended", action="store_true", dest="overwrite", default=False)
	parser.add_argument("-t", "--target_information", help="Use this option to identify an existing ESSID as a target for your project", action="store_true", dest="target_info", default=False)
	parser.add_argument("-c", "--clean_essid", help="Use this option to clean malformed ESSID names in the database", action="store_true", dest="clean_essids", default=False)

	return parser

# clean_bad_essid: 	Some network data contain ESSIDs with a malformed character
#			in them. This function iterates over all captured ESSIDs 
#			and allows the user to decide if that is the case and,
#			if instructed to do so, merge this data into only one ESSID.
# 	db_conn : The database connection
def clean_bad_essid(db_conn):
	cursor=db_conn.cursor()

	cursor.execute('SELECT ESSID FROM SSID')
	rowset = cursor.fetchall()
	essid_list =  [row[0] for row in rowset]
	
	replaced_essids=[]
	real_essids=[]
	for current_essid_index in range(0,len(essid_list)):
		current_essid=essid_list[current_essid_index]
		if current_essid in replaced_essids:
			continue
		lkScreenMsg("Analizing '%s' network... (%d of %d)" % (current_essid,current_essid_index,len(essid_list)))
		similar_essids=[]
		new_essid=""
		if current_essid in real_essids:
			new_essid=current_essid
		for check_essid_index in range(0,len(essid_list)):
			check_essid=essid_list[check_essid_index]
			if check_essid == current_essid or check_essid in replaced_essids:
				continue
			if seems_same_essid(current_essid,check_essid):
				if check_essid in real_essids:
					new_essid=check_essid
				similar_essids.append(check_essid)
	
		# Print list of similar essids
		if len(similar_essids) == 0:
			continue
		lkSMsgMoreIndent()
		lkScreenMsg("This network is similar to:")
		lkSMsgMoreIndent()
		lkScreenMsg("  0:%s (the network beeing analyzed)"%(current_essid))
		_similar_nets = ""
		_netlen = max([len(_e) for _e in similar_essids]) + 4
		for similar_essid_index in range(0,len(similar_essids)):
			_similar_nets += "%3d:%s" % (similar_essid_index+1,similar_essids[similar_essid_index].ljust(_netlen))
		lkScreenMsg(_similar_nets)
		lkSMsgLessIndent()
		if new_essid == '':
			choice=query_option_number("To merge this networks, enter the number of the correct netowrk name (ENTER to skip or 'w' to write down the correct name)",['w'],0,len(similar_essids),None)
			if choice == '':
				replaced_essids.append(current_essid)
				lkSMsgLessIndent()
				continue
			if choice == 'w':
				lkScreenMsg("Enter the right name for this network:")
				new_essid=raw_input()
			else:
				number=int(choice)-1
				if number == -1: 
					new_essid=current_essid
				else:
					new_essid=similar_essids[number]
					similar_essids.append(current_essid)
			real_essids.append(new_essid)
			choice=''
		else:
			choice='a'

		for old_essid in similar_essids:
			if old_essid != new_essid:
				if choice != 'a':
					choice=query_option_number("Do you want to replace '%s' network name with '%s' (yes/no/all)?"%(old_essid,new_essid),['y','n','a'],0,-1,'n')
				else:
					lkScreenMsg("Replacing '%s' network name with '%s'"%(old_essid,new_essid))
						
				if choice == 'y' or choice == 'a':
					change_essid(db_conn, old_essid,new_essid)
					replaced_essids.append(old_essid)
		lkSMsgLessIndent()
					

# change_essid : 	This function changes an essid in all necessary tables of
#			the database.
#	db_conn : the database connection
#	old_essid : the essid to be changed
#	new_essid : the new essid value
def change_essid(db_conn, old_essid, new_essid):
	cursor=db_conn.cursor()
	# Change the SSID table
	sql='''UPDATE OR REPLACE SSID SET
		ESSID = "{a_new_essid}",
		first_seen = (select min(first_seen) from ssid where essid="{a_new_essid}" or essid="{a_old_essid}"),
		last_seen = (select max(last_seen) from ssid where essid="{a_new_essid}" or essid="{a_old_essid}")
		WHERE essid="{a_old_essid}"'''.format(a_new_essid=new_essid,a_old_essid=old_essid)
	cursor.execute(sql)

	# Change the AP_SSID_REL table
	sql='''UPDATE OR REPLACE AP_SSID_REL SET
		SSID_ESSID="{a_new_essid}",
		first_seen = (select min(first_seen) from AP_SSID_REL as R where R.AP_BSSID=AP_BSSID and (R.SSID_ESSID="{a_new_essid}" or R.SSID_ESSID="{a_old_essid}")),
		last_seen = (select max(last_seen) from AP_SSID_REL as R where R.AP_BSSID=AP_BSSID and (R.SSID_ESSID="{a_new_essid}" or R.SSID_ESSID="{a_old_essid}")),
		type = (select type from AP_SSID_REL as R where R.AP_BSSID=AP_BSSID and (R.SSID_ESSID="{a_new_essid}" or R.SSID_ESSID="{a_old_essid}") and R.last_seen=(select max(last_seen) from AP_SSID_REL as RR where RR.AP_BSSID=AP_BSSID and (RR.SSID_ESSID="{a_new_essid}" or RR.SSID_ESSID="{a_old_essid}"))),
		encryption = (select encryption from AP_SSID_REL as R where R.AP_BSSID=AP_BSSID and (R.SSID_ESSID="{a_new_essid}" or R.SSID_ESSID="{a_old_essid}") and R.last_seen=(select max(last_seen) from AP_SSID_REL as RR where RR.AP_BSSID=AP_BSSID and (RR.SSID_ESSID="{a_new_essid}" or RR.SSID_ESSID="{a_old_essid}")))
		WHERE SSID_ESSID="{a_old_essid}"'''.format(a_new_essid=new_essid,a_old_essid=old_essid)
	cursor.execute(sql)

	# Change the CLIENT_SSID_PROBE table
	sql='''UPDATE OR REPLACE CLIENT_SSID_PROBE SET
		SSID_ESSID="{a_new_essid}",
		first_seen = (select min(first_seen) from CLIENT_SSID_PROBE as P where P.CLIENT_MAC=CLIENT_MAC and (P.SSID_ESSID="{a_new_essid}" or P.SSID_ESSID="{a_old_essid}")),
		last_seen = (select max(last_seen) from CLIENT_SSID_PROBE as P where P.CLIENT_MAC=CLIENT_MAC and (P.SSID_ESSID="{a_new_essid}" or P.SSID_ESSID="{a_old_essid}")),
								type = (select type from CLIENT_SSID_PROBE as P where P.CLIENT_MAC=CLIENT_MAC and (P.SSID_ESSID="{a_new_essid}" or P.SSID_ESSID="{a_old_essid}") and P.last_seen=(select max(last_seen) from CLIENT_SSID_PROBE as P where P.CLIENT_MAC=CLIENT_MAC and (P.SSID_ESSID="{a_new_essid}" or P.SSID_ESSID="{a_old_essid}")))
							WHERE SSID_ESSID="{a_old_essid}"'''.format(a_new_essid=new_essid,a_old_essid=old_essid)
	cursor.execute(sql)
	db_conn.commit()

# seems_same_essid: 	Returns True is 2 essids seems to be the same but with
#			some malformed characters.
#	suspect_essid : the essid that we suspect to be the same as another
#	confirmed_essid : the essid that we know is correct in this iteration
#	returns : True if both essid seems to be the same and False otherwise.
def seems_same_essid(suspect_essid, confirmed_essid):
	r_suspect_essid=re.sub(r'\\[0-9]{3}',"?",suspect_essid)
	r_confirmed_essid=re.sub(r'\\[0-9]{3}',"?",confirmed_essid)

	if r_suspect_essid != suspect_essid:
		suspect_wrong_chars=True
	else:
		suspect_wrong_chars=False
	if r_confirmed_essid != confirmed_essid:
		confirmed_wrong_chars=True
	else:
		confirmed_wrong_chars=False
	wrong_chars=suspect_wrong_chars or confirmed_wrong_chars
		
	if len(r_suspect_essid) == len(r_confirmed_essid):
		diffs = 0
		for ch1, ch2 in zip(r_suspect_essid, r_confirmed_essid):
			if ch1 != ch2 and not (ch1.isdigit() and ch2.isdigit()):
				diffs += 1

		if diffs == 0: 
			return False

		if (wrong_chars and (diffs < 5 or diffs < len(r_confirmed_essid)/2)) or (not wrong_chars and (diffs < 3 or diffs <= len(r_confirmed_essid)/4)):
			return True
		else:
			return False
	else:
		return False

# query_option_number:		Prompts the user and asks him to input a number
#				from the keyboard.
#	question : text to be shown to the user
#	options : list containing the option descriptions
#	min_number : the minimum accepted value
#	max_number : the maximum accepted value
#	default : the value to be taken as the default one.
#	returns : the number representing the user choice
def query_option_number(question, options, min_number, max_number, default):
	prompt=""
	if len(options)>0:
		prompt=" ["
		for c in options:
			if c == default:
				prompt=prompt+c.upper()
			else:
				prompt=prompt+c
			if c != options[len(options)-1]:
				prompt=prompt+"/"
		prompt=prompt+"] "
	if (max_number>min_number):
		prompt=prompt+" [%d - %d] " % (min_number,max_number)
	prompt += ":"

	while True:
		lkScreenMsg(question + prompt, ToBeContinued=True)
		choice = raw_input().lower()
		lkSMsgDontContinue()
		if default is not None and choice == '':
			return default
		else:
			if choice == '' or choice in options:
				return choice
			elif choice.isdigit() and int(choice)<=max_number and int(choice)>=min_number:
				return choice
			else:
				lkScreenMsg('Wrong choice!')

# query_yes_no : 	A function the queries the user to type 'y' or 'n'
#			Valid values are 'yes','ye','y','no','n'.
#			The function is not case-sensitive
#	question : the question to be prompted to the user
#	default : a string containing the default answer
#	returns : True if the user answered 'yes' and False otherwise
def query_yes_no(question, default):
        valid = {"yes":True,   "y":True,  "ye":True,
                "no":False,     "n":False}
        if default == None:
                prompt = " [y/n] "
        elif default == "yes":
                prompt = " [Y/n] "
        elif default == "no":
                prompt = " [y/N] "
        else:
                raise ValueError("invalid default answer: '%s'" % default)
        while True:
                lkScreenMsg(question + prompt, ToBeContinued=True)
                choice = raw_input().lower()
		lkSMsgDontContinue()
                if default is not None and choice == '':
                        return valid[default]
                elif choice in valid:
                        return valid[choice]
                else:
                        lkScreenMsg("Please respond with 'yes' or 'no' (or 'y' or 'n').")


# get_enc : 	From a node list, it builds a string containing all supported
#		encryption schemas.
#	nodelist : the node list
#	returns : a string containing all supported encryption schemas.
def get_enc(nodelist):
    full = ''
    nnode = 0
    
    for each in nodelist:
	if nnode > 0:
        	full += " & " + each.text
	else:
        	full += each.text
	nnode += 1
	
    return full

# parse_document : 	This function is the main part of this code. It parses
#			the XML document and inserts all the appropiate values 
#			into the database. 
#	db_conn : the database connection
#	doc : the xml document
def parse_document(db_conn,doc):
	cursor = db_conn.cursor()
	networks = doc.findall('wireless-network')
	n_networks = len(networks)
	n_index = 1
	
	for n in networks:
		lkScreenMsg("Parsing network {arg1} of {arg2}".format(arg1=n_index,arg2=n_networks),ToBeRewritten=True)

		bssid = n.find('BSSID').text
		networktype = n.attrib.get('type')
		manuf = n.find('manuf').text
		channel = n.find('channel').text
		dateinsert = datetime.datetime.strptime(n.attrib.get("first-time"),"%a %b %d %H:%M:%S %Y")
		dateupdate = datetime.datetime.strptime(n.attrib.get("last-time"),"%a %b %d %H:%M:%S %Y")
		# ACCESS_POINT ENTRY
		try:
			cursor.execute('INSERT INTO ACCESS_POINT VALUES("{a_bssid}", "{a_type}", "{a_manuf}", {a_channel}, "{a_first_seen}", "{a_last_seen}")'.format(a_bssid=bssid,a_type=networktype,a_manuf=manuf,a_channel=channel,a_first_seen=dateinsert,a_last_seen=dateupdate))
		except sqlite3.IntegrityError:
			sql = '''UPDATE ACCESS_POINT SET 
				type = CASE WHEN (select rowid from AUX_BSSID_TYPES WHERE AUX_BSSID_TYPES.type = ACCESS_POINT.type) > (select rowid from AUX_BSSID_TYPES WHERE AUX_BSSID_TYPES.type = "{a_type}") THEN "{a_type}" ELSE type END,
				channel = CASE WHEN "{a_last_seen}" > last_seen THEN {a_channel} ELSE channel END,
				first_seen = CASE WHEN "{a_first_seen}" < first_seen THEN '{a_first_seen}' ELSE first_seen END,
				last_seen = CASE WHEN "{a_last_seen}" > last_seen THEN '{a_last_seen}' ELSE last_seen END
				WHERE BSSID = "{a_bssid}";
				'''.format(a_bssid=bssid, a_type=networktype, a_channel=channel, a_first_seen=dateinsert, a_last_seen=dateupdate)
			cursor.execute(sql);
		db_conn.commit()

		# SSID Entries
		ssids = n.findall('SSID')
		n_ssids = len(ssids)
		ssid_index = 1
		for ssid in ssids:
			lkScreenMsg("Parsing network {arg1} of {arg2} [ ssid {arg3} of {arg4} ]".format(arg1=n_index,arg2=n_networks, arg3=ssid_index, arg4=n_ssids),ToBeRewritten=True)
			if ssid.find('essid') is None:
				essid = 'unknown'
			else:
				if ssid.find('essid').text:
					essid = escape(ssid.find('essid').text).replace('"',"''")
				else:
					essid = 'hidden'
			ssid_type = ssid.find('type').text
			ssid_first_seen = datetime.datetime.strptime(n.attrib.get('first-time'),"%a %b %d %H:%M:%S %Y")
			ssid_last_seen = datetime.datetime.strptime(n.attrib.get('last-time'),"%a %b %d %H:%M:%S %Y")
			encryption = get_enc(ssid.findall('encryption'))
			# Look for essids that seems to be the same as this one (same BSSID and similar name)
			sql = ''' SELECT SSID_ESSID FROM AP_SSID_REL WHERE AP_BSSID = "{a_ap_bssid}" AND SSID_ESSID <> "{a_essid}";'''.format(a_ap_bssid=bssid, a_essid=essid)
			cursor.execute(sql)
			rowset = cursor.fetchall()
			for row in rowset:
				if seems_same_essid(essid,row[0]):
					lkScreenMsg()
					lkSMsgMoreIndent()
					lkScreenMsg("Network '%s' (the one beeing analyzed) seems to be the same as existing '%s' !" % (essid,row[0]))
					if query_yes_no("Do you confirm it (y/n)?",None):
						valid_choice=False
						while not valid_choice:
							try:
								lkScreenMsg("Which one is the correct one?")
								lkSMsgMoreIndent()
								lkScreenMsg("1:%s 2:%s \t--> " % (essid,row[0]), ToBeContinued=True)
								choice=int(raw_input())
								lkSMsgDontContinue()
								lkSMsgLessIndent()
								if choice in range(1,3):
									valid_choice=True
							except ValueError:
								pass
						if choice == 1:
							# Change existing essid because it is wrong
							old_essid=row[0]
							new_essid=essid
							change_essid(db_conn, old_essid,new_essid);
						else:
							# Change the essid (just in case) Perhaps this is not necessary ?
							old_essid=essid
							new_essid=row[0]
							change_essid(db_conn, old_essid,new_essid);
							# Continue using the right essid
							essid=new_essid
							lkSMsgLessIndent()
							break
					lkSMsgLessIndent()

			# Now the essid is correct! Continue updating db.
			try:
				cursor.execute('INSERT INTO SSID VALUES("{a_essid}","{a_first_seen}","{a_last_seen}",0,NULL)'.format(a_essid=essid, a_first_seen=ssid_first_seen, a_last_seen=ssid_last_seen))
			except sqlite3.IntegrityError:
				sql='''UPDATE SSID SET
					first_seen = CASE WHEN "{a_first_seen}" < first_seen THEN "{a_first_seen}" ELSE first_seen END,
					last_seen = CASE WHEN "{a_last_seen}" > last_seen THEN "{a_last_seen}" ELSE last_seen END
					WHERE essid = "{a_essid}";
				'''.format(a_essid=essid, a_first_seen=ssid_first_seen, a_last_seen=ssid_last_seen)
				cursor.execute(sql)
			db_conn.commit()
		
			try:
				cursor.execute('INSERT INTO AP_SSID_REL VALUES("{a_ap_bssid}","{a_ssid_essid}","{a_type}","{a_encryption}","{a_first_seen}","{a_last_seen}")'.format(a_ap_bssid=bssid, a_ssid_essid=essid, a_type=ssid_type, a_encryption=encryption, a_first_seen=ssid_first_seen, a_last_seen=ssid_last_seen))
			except sqlite3.IntegrityError:
				sql='''UPDATE AP_SSID_REL SET
					type = CASE WHEN (SELECT rowid FROM AUX_AP_SSID_TYPES WHERE type="{a_ssid_type}") < (SELECT rowid FROM AUX_AP_SSID_TYPES WHERE AUX_AP_SSID_TYPES.type = AP_SSID_REL.type) THEN "{a_ssid_type}" ELSE type END,
					encryption = CASE WHEN "{a_ssid_last_seen}" > last_seen THEN "{a_ssid_encryption}" ELSE encryption END,
					first_seen = CASE WHEN "{a_ssid_first_seen}" < first_seen THEN "{a_ssid_first_seen}" ELSE first_seen END,
					last_seen = CASE WHEN "{a_ssid_last_seen}" > last_seen THEN "{a_ssid_last_seen}" ELSE last_seen END
					WHERE AP_BSSID = "{a_ap_bssid}" and SSID_ESSID = "{a_ssid_essid}";
				'''.format(a_ssid_type=ssid_type, a_ssid_encryption=encryption, a_ssid_last_seen=ssid_last_seen, a_ssid_first_seen=ssid_first_seen, a_ap_bssid=bssid, a_ssid_essid=essid)


				cursor.execute(sql)
			db_conn.commit()
	
			ssid_index += 1

		# Client Entries
		clients = n.findall("wireless-client")
		c_index = 1
		n_clients = len(clients)
		for client in clients:
			lkScreenMsg("Parsing network {arg1} of {arg2} [ client {arg3} of {arg4} ]    ".format(arg1=n_index,arg2=n_networks, arg3=c_index, arg4=n_clients),ToBeRewritten=True)
			mac = client.find('client-mac').text
			if mac == bssid:
				c_index += 1
				continue
			manufacturer = client.find('client-manuf').text
			client_first_seen = datetime.datetime.strptime(client.attrib.get('first-time'),"%a %b %d %H:%M:%S %Y")
			client_last_seen = datetime.datetime.strptime(client.attrib.get('last-time'),"%a %b %d %H:%M:%S %Y")
			client_type = client.attrib.get('type')

			try:
				cursor.execute('INSERT INTO CLIENT VALUES("{a_mac}","{a_manufacturer}","{a_first_seen}","{a_last_seen}")'.format(a_mac=mac, a_manufacturer=manufacturer, a_first_seen=client_first_seen, a_last_seen=client_last_seen))
			except sqlite3.IntegrityError:
				sql='''UPDATE CLIENT SET
					first_seen = CASE WHEN "{a_first_seen}" < first_seen THEN "${a_first_seen}" ELSE first_seen END,
					last_seen = CASE WHEN "{a_last_seen}" > last_seen THEN "{a_last_seen}" ELSE last_seen END
					WHERE MAC = "a_mac"
				'''.format(a_mac=mac, a_first_seen=client_first_seen, a_last_seen=client_last_seen)
				cursor.execute(sql)
			db_conn.commit()

			try:
				cursor.execute('INSERT INTO CLIENT_AP_REL VALUES("{a_ap_bssid}","{a_client_mac}","{a_type}","{a_first_seen}","{a_last_seen}");'.format(a_ap_bssid=bssid, a_client_mac=mac, a_type=client_type, a_first_seen=client_first_seen, a_last_seen=client_last_seen))
			except sqlite3.IntegrityError:
				sql='''UPDATE CLIENT_AP_REL SET
					type = CASE WHEN (SELECT rowid FROM AUX_CLIENT_AP_TYPES WHERE type = "{a_type}") < (SELECT rowid FROM AUX_CLIENT_AP_TYPES WHERE AUX_CLIENT_AP_TYPES.type = CLIENT_AP_REL.type) THEN "{a_type}" ELSE type END,
					first_seen = CASE WHEN "{a_first_seen}" < first_seen THEN "{a_first_seen}" ELSE first_seen END,
					last_seen = CASE WHEN "{a_last_seen}" > last_seen THEN "{a_last_seen}" ELSE last_seen END
					WHERE CLIENT_MAC = "{a_client_mac}" AND AP_BSSID = "{a_ap_bssid}"
				'''.format(a_type=client_type, a_first_seen=client_first_seen, a_last_seen=client_last_seen, a_client_mac=mac, a_ap_bssid=bssid)
				cursor.execute(sql)
			db_conn.commit()
			
			c_ssids = client.findall('SSID')
			for c_ssid in c_ssids:
				if c_ssid.find('ssid') is None:
					if bssid == "FF:FF:FF:FF:FF:FF":
						c_ssid_essid = 'any'
					else:
						c_ssid_essid = 'unknown'
						
				else:
					if c_ssid.find('ssid').text:
						c_ssid_essid = escape(c_ssid.find('ssid').text).replace('"',"''")
					else:
						if bssid == "FF:FF:FF:FF:FF:FF":
							c_ssid_essid = 'any'
						else:
							c_ssid_essid = 'unknown'
				c_ssid_type = c_ssid.find('type').text
				c_ssid_first_seen = c_ssid.attrib.get('first-time')
				c_ssid_last_seen = c_ssid.attrib.get('last-time')
				
				try:
					cursor.execute('INSERT INTO CLIENT_SSID_PROBE VALUES("{a_client_mac}","{a_ssid_essid}","{a_type}","{a_first_seen}","{a_last_seen}");'.format(a_client_mac=mac, a_ssid_essid=c_ssid_essid, a_type=c_ssid_type, a_first_seen=c_ssid_first_seen, a_last_seen=c_ssid_last_seen))
				except sqlite3.IntegrityError:
					sql='''UPDATE CLIENT_SSID_PROBE SET
						type = CASE WHEN (SELECT rowid FROM AUX_CLIENT_SSID_PROBE_TYPES WHERE type = "{a_type}") < (SELECT rowid FROM AUX_CLIENT_SSID_PROBE_TYPES WHERE AUX_CLIENT_SSID_PROBE_TYPES.type = CLIENT_SSID_PROBE.type) THEN "{a_type}" ELSE type END,
						first_seen = CASE WHEN "{a_first_seen}" < first_seen THEN "{a_first_seen}" ELSE first_seen END,
						last_seen = CASE WHEN "{a_last_seen}" > last_seen THEN "{a_last_seen}" ELSE last_seen END
						WHERE CLIENT_MAC = "{a_client_mac}" AND SSID_ESSID = "{a_ssid_essid}";
					'''.format(a_client_mac=mac, a_ssid_essid=c_ssid_essid, a_last_seen=c_ssid_last_seen, a_first_seen=c_ssid_first_seen, a_type=c_ssid_type)
					cursor.execute(sql)
				db_conn.commit()
					
			c_index += 1

		n_index += 1
		
	lkScreenMsg()
	lkScreenMsg("Finished.")
	lkScreenMsg()


# check_create_db:	If the databse does not exist, this function creates it.
#			If the database exists, then the function opens it.
#	db : the filename of the database
#	return : the database connection
def check_create_db(db):
	global args

	dbfilename = db
	FileExists = False

	# Check if the file exists and has something inside
	if os.path.isfile(dbfilename):
		# Check file length > 0
		if os.path.getsize(dbfilename) > 0:
			FileExists = True

	if not FileExists or args.overwrite:
		conn = sqlite3.connect(dbfilename)
    		c = conn.cursor()
		if args.overwrite and FileExists:
			lkScreenMsg("Re-initializing existing database (overwrite flag present).")
			c.execute('DROP TABLE IF EXISTS SSID;')
			c.execute('DROP TABLE IF EXISTS CLIENT;')
			c.execute('DROP TABLE IF EXISTS ACCESS_POINT;')
			c.execute('DROP TABLE IF EXISTS CLIENT_AP_REL;')
			c.execute('DROP TABLE IF EXISTS AP_SSID_REL;')
			c.execute('DROP TABLE IF EXISTS CLIENT_SSID_PROBE;')
			c.execute('DROP TABLE IF EXISTS AUX_BSSID_TYPES;')
			c.execute('DROP TABLE IF EXISTS AUX_AP_SSID_TYPES;')
			c.execute('DROP TABLE IF EXISTS AUX_CLIENT_AP_TYPES;')
			c.execute('DROP TABLE IF EXISTS AUX_CLIENT_SSID_PROBE_TYPES;')
			conn.commit()
		else:
			lkScreenMsg("Creating database.")

		# Create the file and initialize the database
    		c.execute( ''' CREATE TABLE ACCESS_POINT ( 
				BSSID TEXT PRIMARY KEY,
				type TEXT NOT NULL,
				manufacturer TEXT NOT NULL,
				channel INTEGER NOT NULL,
				first_seen NOT NULL,
				last_seen NOT NULL);''')
    		c.execute( ''' CREATE TABLE CLIENT (
				MAC TEXT PRIMARY KEY,
				manufacturer TEXT NOT NULL,
				first_seen NOT NULL,
				last_seen NOT NULL);''')
    		c.execute( ''' CREATE TABLE CLIENT_AP_REL (
				AP_BSSID TEXT NOT NULL REFERENCES ACCESS_POINT(BSSID),
				CLIENT_MAC TEXT NOT NULL REFERENCES CLIENT(MAC),
				type TEXT NOT NULL,
				first_seen NOT NULL,
				last_seen NOT NULL,
				PRIMARY KEY (AP_BSSID,CLIENT_MAC) );''')
    		c.execute( ''' CREATE TABLE SSID (
				ESSID TEXT PRIMARY KEY,
				first_seen NOT NULL,
				last_seen NOT NULL,
				is_target INTEGER NOT NULL,
				why_is_target TEXT);''')
    		c.execute( ''' CREATE TABLE AP_SSID_REL (
				AP_BSSID TEXT NOT NULL REFERENCES ACCESS_POINT(BSSID),
				SSID_ESSID TEXT NOT NULL REFERENCES SSID(ESSID),
				type TEXT NOT NULL,
				encryption TEXT NOT NULL,
				first_seen NOT NULL,
				last_seen NOT NULL,
				PRIMARY KEY (AP_BSSID,SSID_ESSID) );''')
    		c.execute( ''' CREATE TABLE CLIENT_SSID_PROBE (
				CLIENT_MAC TEXT NOT NULL REFERENCES CLIENT(MAC),
				SSID_ESSID TEXT NOT NULL REFERENCES SSID(ESSID),
				type TEXT NOT NULL,
				first_seen NOT NULL,
				last_seen NOT NULL,
				PRIMARY KEY (CLIENT_MAC,SSID_ESSID) );''')
		c.execute( ''' CREATE TABLE AUX_BSSID_TYPES (
				type TEXT UNIQUE ); ''')
		c.execute( "INSERT INTO AUX_BSSID_TYPES VALUES('infrastructure');" )
		c.execute( "INSERT INTO AUX_BSSID_TYPES VALUES('data');" )
		c.execute( "INSERT INTO AUX_BSSID_TYPES VALUES('ad-hoc');" )
		c.execute( "INSERT INTO AUX_BSSID_TYPES VALUES('probe');" )
		c.execute( "INSERT INTO AUX_BSSID_TYPES VALUES('turbocell');" )
		c.execute( "INSERT INTO AUX_BSSID_TYPES VALUES('unknown');" )
		c.execute( ''' CREATE TABLE AUX_AP_SSID_TYPES (
				type TEXT UNIQUE ); ''')
		c.execute( "INSERT INTO AUX_AP_SSID_TYPES VALUES('Beacon');" )
		c.execute( "INSERT INTO AUX_AP_SSID_TYPES VALUES('Probe Response');" )
		c.execute( "INSERT INTO AUX_AP_SSID_TYPES VALUES('Cached SSID');" )
		c.execute( ''' CREATE TABLE AUX_CLIENT_AP_TYPES (
				type TEXT UNIQUE ); ''')
		c.execute( "INSERT INTO AUX_CLIENT_AP_TYPES VALUES('tods');" )
		c.execute( "INSERT INTO AUX_CLIENT_AP_TYPES VALUES('todsinferred');" )
		c.execute( "INSERT INTO AUX_CLIENT_AP_TYPES VALUES('established');" )
		c.execute( "INSERT INTO AUX_CLIENT_AP_TYPES VALUES('establishedinferred');" )
		c.execute( "INSERT INTO AUX_CLIENT_AP_TYPES VALUES('ad-hoc');" )
		c.execute( "INSERT INTO AUX_CLIENT_AP_TYPES VALUES('fromds');" )
		c.execute( "INSERT INTO AUX_CLIENT_AP_TYPES VALUES('interds');" )
		c.execute( "INSERT INTO AUX_CLIENT_AP_TYPES VALUES('unknown');" )
		c.execute( ''' CREATE TABLE AUX_CLIENT_SSID_PROBE_TYPES (
				type TEXT UNIQUE ); ''')
		c.execute( "INSERT INTO AUX_CLIENT_SSID_PROBE_TYPES VALUES('Beacon');" )
		c.execute( "INSERT INTO AUX_CLIENT_SSID_PROBE_TYPES VALUES('Probe Response');" )
		c.execute( "INSERT INTO AUX_CLIENT_SSID_PROBE_TYPES VALUES('Probe Request');" )
			
    		conn.commit()
	else:
		conn = sqlite3.connect(dbfilename)

	return conn

# add_target_information:	This function asks the user what ESSIDs must be 
#				considered as targets, and modifies the database
#				records accordingly
#	conn : the database connection
def add_target_information(conn):

	cursor = conn.cursor()
	end = False
	while not end:
		lkScreenMsg("ESSID to be considered as target (or hit ENTER to skip): ", ToBeContinued=True)
		essid = raw_input()
		lkSMsgDontContinue()
		if len(essid) == 0:
			return
		n_rows = cursor.execute('SELECT COUNT() from SSID WHERE ESSID = "{a_essid}"'.format(a_essid=essid)).fetchone()
		
		if n_rows[0] == 0:
			lkScreenMsg('ESSID "{a_essid}" does not exist in the database!'.format(a_essid=essid))
		else:
			lkScreenMsg("Write a description on why it is a target: ", ToBeContinued=True)
			reason = raw_input()
			lkSMsgDontContinue()
			cursor.execute('''UPDATE SSID SET
						is_target = 1,
						why_is_target = "{a_why_is_target}"
					WHERE ESSID = "{a_essid}"'''.format(a_essid=essid, a_why_is_target=reason))
			conn.commit()
		
# update_targets:	Based on BSSID proximity, it suggest some new ESSID that 
#			are new potential targets, and asks the user to confirm
#			this. If confirmed, the new ESSIDs are marked as target
#			in the database.
#	conn : the database connection
def update_targets(conn):
	lkScreenMsg("Looking for potential additional targets...")
	c = conn.cursor()

	finished = False
	flag = False
	while not finished:
		if flag:
			lkScreenMsg("___ More potential additional targets:")
		else:
			lkScreenMsg("___ Potential additional targets:")
			flag = True
		lkSMsgMoreIndent()
		potential_essids = []
		sql = '''
			SELECT AP_SSID_REL.AP_BSSID, SSID.ESSID, SSID.is_target
			FROM SSID JOIN AP_SSID_REL ON SSID.ESSID = AP_SSID_REL.SSID_ESSID
			ORDER BY AP_SSID_REL.AP_BSSID, SSID.ESSID;
		'''
		c.execute(sql)
		rowset = c.fetchall()
		rowcount = 0
		for row in rowset:
			if rowcount > 0:
				if row[2] == 0:
					if rowset[rowcount-1][2] == 1:
						if rowset[rowcount-1][0][0:8] == row[0][0:8] and row[0][0:8] != "ff:ff:ff" and row[1] != "hidden":
							ndifferences = 0
							for pos in range(9,17):
								if rowset[rowcount-1][0][pos] != row[0][pos]:
									ndifferences += 1
							if ndifferences == 0:
								if len([i for i in potential_essids if i[0] == row[1]]) == 0:
									potential_essids.append((row[1],"Shares mac " + row[0] + " with " + rowset[rowcount-1][1]))
							elif ndifferences == 1:
								if len([i for i in potential_essids if i[0] == row[1]]) == 0:
									potential_essids.append((row[1],"Has mac " + row[0] + " contiguous to " + rowset[rowcount-1][0] + " of " + rowset[rowcount-1][1]))

			rowcount += 1

		if len(potential_essids) > 0:
			for p in potential_essids:
				lkScreenMsg("%s: %s" % (p))
			if query_yes_no("Do you want to add them to 'target_essids' table ?", "yes"):
				for p in potential_essids:
					c.execute('UPDATE SSID SET is_target = 1, why_is_target = "{a_reason}"  WHERE ESSID = "{a_essid}";'.format(a_essid=p[0], a_reason=p[1]))
				conn.commit()
			else:
				finished = True
		else:
			if flag:
				lkScreenMsg("No more potential target essids found.")
			else:
				lkScreenMsg("No potential target essids found.")
			finished = True
		lkSMsgLessIndent()
###
### GLOBALS
###
ouifilename = "/usr/share/wireshark/manuf"
parser = None

###
### MAIN
###
parser = create_argumentparser()
args = parser.parse_args()

lkSMsgSetIndentLevel(0)
lkScreenMsg("lk_k2db.py (v1.0) - Kismet XML to sqlite3 database extraction tool.")
lkScreenMsg("Copyright (c) 2015 Layakk (www.layakk.com) (@layakk)")
lkScreenMsg()

lkScreenMsg("___ INITIALIZATION ___", IndentLevel=0)
lkSMsgMoreIndent()
lkScreenMsg("Verifying command line options...")

lkSMsgMoreIndent()
if args.filename:
	lkScreenMsg("Information from %s will be added to the database." % args.filename)
else:
	if not args.target_info and not args.clean_essids:
		lkScreenMsg("ERROR! You must supply an input filename (unless you only want to add target information or clean essid names).")
		lkScreenMsg("Exiting.")
		exit(1)
	else:
		if args.target_info:
			lkScreenMsg("User will choose target ESSIDs in this execution.")
		if args.clean_essids:
			lkScreenMsg("Malformed essids verification will be performed in this execution.")
lkScreenMsg("OK!")
lkSMsgLessIndent()

lkScreenMsg("Initializing database connection...")
lkSMsgMoreIndent()
# Check for the file and create it if necessary
db_connection = check_create_db(args.database)
lkScreenMsg("OK!")
lkSMsgLessIndent()

lkScreenMsg("___ EXECUTION ___", IndentLevel=0)
lkSMsgMoreIndent()

# Load network data
if args.filename:
	lkScreenMsg("Getting information from input file '%s'" % args.filename)
	lkSMsgMoreIndent()
	lkScreenMsg("Parsing XML file...")
	document = etree.parse(args.filename)

	# Parse and save data
	lkScreenMsg("Processing WiFi data...")
	lkSMsgMoreIndent()
	parse_document(db_connection, document)
	lkSMsgLessIndent()

# Clean the database
if args.clean_essids: 
	lkScreenMsg("Cleaning potentially malformed ESSIDs...")
	lkSMsgMoreIndent()
	clean_bad_essid(db_connection)
	lkSMsgLessIndent()

# Specify target information
if args.target_info: 
	lkScreenMsg("Specifying target information...")
	lkSMsgMoreIndent()
	add_target_information(db_connection)
	lkSMsgLessIndent()

# Update target information
lkScreenMsg("Updating new target information...")
lkSMsgMoreIndent()
update_targets(db_connection)
lkSMsgLessIndent()

lkScreenMsg("___ TERMINATION ___", IndentLevel=0)
lkSMsgMoreIndent()
lkScreenMsg("Closing database connection...")
lkSMsgMoreIndent()
db_connection.close()
lkSMsgLessIndent()
lkScreenMsg("Exiting.")
exit(0)
